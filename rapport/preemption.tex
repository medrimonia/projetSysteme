\section{Préemption}

La préemption était l'un des objectifs avancés du code utilisateur.
Nous avons essayé de la réaliser à l'aide d'un timer à l'aide des fonctions \textit{setitimer}) et \textit{getitimer}. Notre timer virtuel est créé afin d'envoyer, tous les \textit{timeslices} secondes, un signal \textit{ITIMER\_VIRTUAL} à l'application. Il décroit lors de l'exécution du processus.
 A la réception de ce signal de préemption, notre bibliothèque de thread devrait reprend la main sur le code exécuté et effectue un appel à \textit{thread\_yield} pour changer de contexte.\\
Le timer est créé à la création du premier thread du programme et est détruit à la disparition de ce thread
\\
Il est réinitialisé dans \verb$thread_yield$, \verb$thread_join$ et
\verb$thread_exit$, pour que le thread qui reprend la main ait lui aussi le temps d'exécution disponible \verb$TIMESLICE$. 

Dans un premier temps, nous avions pensé donné à la variable \verb$TIMESLICE$ une valeur fixée, mais ensuite nous avions envisager de donner à cette varaiable une valeur fonction de la priorité du thread en question.
\\
La préemption introduit malheureusement de nouveaux problèmes. Si un changement de contexte se produit au moment où la bibliothèque est en train de modifier son état interne dans une des fonctions de l'API peut (et c'est souvent le cas) engendrer un état incohérent. Ce phénomène étant difficile à prévoir du fait de son caractère non déterminisme de préemption. La seule solution est de désactiver temporairement la préemption durant l'exécution du code des fonctions critiques de l'API. Ceci est réalisé à l'aide de la fonction \textit{sigprocmask()} qui permet de préciser les signaux bloqués et dont le traitement est reporté après leur réactivation. Nous avions utilisé en interne les deux fonctions \textit{preemption\_allow()} et \textit{preemption\_protect()} pour nous protéger de ces erreurs.\\

Cependant les tests effectués sur la préemption n'ont pas été concluant. Nous avons eu des difficultés pour obtenir l'état du timer et pour propager le signal \textit{ITIMER\_VIRTUAL} à l'application. Nous avons ainsi préferer enlever ce qui avait été mis en place par souci de clarté, tout en laissant nos deux fonctions internes \textit{preemption\_allow()} et \textit{preemption\_protect()}
